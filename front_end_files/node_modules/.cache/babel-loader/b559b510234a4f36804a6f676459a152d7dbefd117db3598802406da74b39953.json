{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.bytesToHex = bytesToHex;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */BigInt(0);\nconst _1n = /* @__PURE__ */BigInt(1);\nconst _2n = /* @__PURE__ */BigInt(2);\nfunction isBytes(a) {\n  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';\n}\nfunction abytes(item) {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n  _0: 48,\n  _9: 57,\n  _A: 65,\n  _F: 70,\n  _a: 97,\n  _f: 102\n};\nfunction asciiToBase16(char) {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = n => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = data => new Uint8Array(data); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  stringOrUint8Array: val => typeof val === 'string' || isBytes(val),\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error(`Invalid validator \"${type}\", expected function`);\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });","map":{"version":3,"names":["exports","isBytes","abytes","bytesToHex","numberToHexUnpadded","hexToNumber","hexToBytes","bytesToNumberBE","bytesToNumberLE","numberToBytesBE","numberToBytesLE","numberToVarBytesBE","ensureBytes","concatBytes","equalBytes","utf8ToBytes","bitLen","bitGet","bitSet","createHmacDrbg","validateObject","_0n","BigInt","_1n","_2n","a","Uint8Array","constructor","name","item","Error","hexes","Array","from","length","_","i","toString","padStart","bytes","hex","num","asciis","_0","_9","_A","_F","_a","_f","asciiToBase16","char","hl","al","array","ai","hi","n1","charCodeAt","n2","undefined","reverse","n","len","title","expectedLength","res","e","arrays","sum","pad","set","b","diff","str","TextEncoder","encode","pos","value","bitMask","u8n","data","u8fr","arr","hashLen","qByteLen","hmacFn","v","k","reset","fill","h","reseed","seed","gen","out","sl","slice","push","genUntil","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isSafeInteger","Number","isArray","field","object","Fp","isValid","hash","outputLen","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries"],"sources":["C:\\Users\\gcalb\\OneDrive\\galboum\\My_Projects\\CryptoToken\\PotLockCoin\\potlocktoken-dapp-v2\\potlocktoken-dapp-v2\\starter-files\\node_modules\\@noble\\curves\\src\\abstract\\utils.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean) {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}