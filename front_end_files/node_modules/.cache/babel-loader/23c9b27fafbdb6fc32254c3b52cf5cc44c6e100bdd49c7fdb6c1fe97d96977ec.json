{"ast":null,"code":"import Web3 from \"web3\";\n\n// Initialize Web3\nconst web3 = new Web3(window.ethereum);\n\n// Replace this with your deployed contract's ABI and address\nconst contractABI = [/* Your contract's ABI goes here */];\nconst contractAddress = \"YOUR_CONTRACT_ADDRESS\";\nexport const tokenContract = new web3.eth.Contract(contractABI, contractAddress);\n\n// Fetch contract variables\nexport const getContractVariables = async () => {\n  try {\n    const maxTokensPerWallet = await tokenContract.methods.maxTokensPerWallet().call();\n    const sellTimeframe = await tokenContract.methods.sellTimeframe().call();\n    const totalSupply = await tokenContract.methods.totalSupply().call();\n    return {\n      maxTokensPerWallet,\n      sellTimeframe,\n      totalSupply\n    };\n  } catch (err) {\n    console.error(err);\n    return {\n      maxTokensPerWallet: 0,\n      sellTimeframe: 0,\n      totalSupply: 0\n    };\n  }\n};\n\n// Burn tokens\nexport const burnTokens = async amount => {\n  const accounts = await window.ethereum.request({\n    method: \"eth_requestAccounts\"\n  });\n  const account = accounts[0];\n  try {\n    const receipt = await tokenContract.methods.burn(amount).send({\n      from: account\n    });\n    return {\n      success: true,\n      receipt\n    };\n  } catch (err) {\n    console.error(err);\n    return {\n      success: false,\n      error: err.message\n    };\n  }\n};\n\n// Listen to contract events\nexport const addContractEventListeners = eventHandlers => {\n  tokenContract.events.WalletChosen({}, eventHandlers.walletChosen);\n  tokenContract.events.TimeframeUpdated({}, eventHandlers.timeframeUpdated);\n  tokenContract.events.HolderListUpdated({}, eventHandlers.holderListUpdated);\n  tokenContract.events.Burn({}, eventHandlers.burn);\n};","map":{"version":3,"names":["Web3","web3","window","ethereum","contractABI","contractAddress","tokenContract","eth","Contract","getContractVariables","maxTokensPerWallet","methods","call","sellTimeframe","totalSupply","err","console","error","burnTokens","amount","accounts","request","method","account","receipt","burn","send","from","success","message","addContractEventListeners","eventHandlers","events","WalletChosen","walletChosen","TimeframeUpdated","timeframeUpdated","HolderListUpdated","holderListUpdated","Burn"],"sources":["C:/Users/gcalb/OneDrive/galboum/My_Projects/CryptoToken/PotLockCoin/potlocktoken-dapp-v2/potlocktoken-dapp-v2/starter-files/src/util/interact.js"],"sourcesContent":["import Web3 from \"web3\";\r\n\r\n// Initialize Web3\r\nconst web3 = new Web3(window.ethereum);\r\n\r\n// Replace this with your deployed contract's ABI and address\r\nconst contractABI = [/* Your contract's ABI goes here */];\r\nconst contractAddress = \"YOUR_CONTRACT_ADDRESS\";\r\n\r\nexport const tokenContract = new web3.eth.Contract(contractABI, contractAddress);\r\n\r\n// Fetch contract variables\r\nexport const getContractVariables = async () => {\r\n  try {\r\n    const maxTokensPerWallet = await tokenContract.methods.maxTokensPerWallet().call();\r\n    const sellTimeframe = await tokenContract.methods.sellTimeframe().call();\r\n    const totalSupply = await tokenContract.methods.totalSupply().call();\r\n\r\n    return { maxTokensPerWallet, sellTimeframe, totalSupply };\r\n  } catch (err) {\r\n    console.error(err);\r\n    return { maxTokensPerWallet: 0, sellTimeframe: 0, totalSupply: 0 };\r\n  }\r\n};\r\n\r\n// Burn tokens\r\nexport const burnTokens = async (amount) => {\r\n  const accounts = await window.ethereum.request({ method: \"eth_requestAccounts\" });\r\n  const account = accounts[0];\r\n  try {\r\n    const receipt = await tokenContract.methods.burn(amount).send({ from: account });\r\n    return { success: true, receipt };\r\n  } catch (err) {\r\n    console.error(err);\r\n    return { success: false, error: err.message };\r\n  }\r\n};\r\n\r\n// Listen to contract events\r\nexport const addContractEventListeners = (eventHandlers) => {\r\n  tokenContract.events.WalletChosen({}, eventHandlers.walletChosen);\r\n  tokenContract.events.TimeframeUpdated({}, eventHandlers.timeframeUpdated);\r\n  tokenContract.events.HolderListUpdated({}, eventHandlers.holderListUpdated);\r\n  tokenContract.events.Burn({}, eventHandlers.burn);\r\n};\r\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,MAAM;;AAEvB;AACA,MAAMC,IAAI,GAAG,IAAID,IAAI,CAACE,MAAM,CAACC,QAAQ,CAAC;;AAEtC;AACA,MAAMC,WAAW,GAAG,CAAC,oCAAoC;AACzD,MAAMC,eAAe,GAAG,uBAAuB;AAE/C,OAAO,MAAMC,aAAa,GAAG,IAAIL,IAAI,CAACM,GAAG,CAACC,QAAQ,CAACJ,WAAW,EAAEC,eAAe,CAAC;;AAEhF;AACA,OAAO,MAAMI,oBAAoB,GAAG,MAAAA,CAAA,KAAY;EAC9C,IAAI;IACF,MAAMC,kBAAkB,GAAG,MAAMJ,aAAa,CAACK,OAAO,CAACD,kBAAkB,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;IAClF,MAAMC,aAAa,GAAG,MAAMP,aAAa,CAACK,OAAO,CAACE,aAAa,CAAC,CAAC,CAACD,IAAI,CAAC,CAAC;IACxE,MAAME,WAAW,GAAG,MAAMR,aAAa,CAACK,OAAO,CAACG,WAAW,CAAC,CAAC,CAACF,IAAI,CAAC,CAAC;IAEpE,OAAO;MAAEF,kBAAkB;MAAEG,aAAa;MAAEC;IAAY,CAAC;EAC3D,CAAC,CAAC,OAAOC,GAAG,EAAE;IACZC,OAAO,CAACC,KAAK,CAACF,GAAG,CAAC;IAClB,OAAO;MAAEL,kBAAkB,EAAE,CAAC;MAAEG,aAAa,EAAE,CAAC;MAAEC,WAAW,EAAE;IAAE,CAAC;EACpE;AACF,CAAC;;AAED;AACA,OAAO,MAAMI,UAAU,GAAG,MAAOC,MAAM,IAAK;EAC1C,MAAMC,QAAQ,GAAG,MAAMlB,MAAM,CAACC,QAAQ,CAACkB,OAAO,CAAC;IAAEC,MAAM,EAAE;EAAsB,CAAC,CAAC;EACjF,MAAMC,OAAO,GAAGH,QAAQ,CAAC,CAAC,CAAC;EAC3B,IAAI;IACF,MAAMI,OAAO,GAAG,MAAMlB,aAAa,CAACK,OAAO,CAACc,IAAI,CAACN,MAAM,CAAC,CAACO,IAAI,CAAC;MAAEC,IAAI,EAAEJ;IAAQ,CAAC,CAAC;IAChF,OAAO;MAAEK,OAAO,EAAE,IAAI;MAAEJ;IAAQ,CAAC;EACnC,CAAC,CAAC,OAAOT,GAAG,EAAE;IACZC,OAAO,CAACC,KAAK,CAACF,GAAG,CAAC;IAClB,OAAO;MAAEa,OAAO,EAAE,KAAK;MAAEX,KAAK,EAAEF,GAAG,CAACc;IAAQ,CAAC;EAC/C;AACF,CAAC;;AAED;AACA,OAAO,MAAMC,yBAAyB,GAAIC,aAAa,IAAK;EAC1DzB,aAAa,CAAC0B,MAAM,CAACC,YAAY,CAAC,CAAC,CAAC,EAAEF,aAAa,CAACG,YAAY,CAAC;EACjE5B,aAAa,CAAC0B,MAAM,CAACG,gBAAgB,CAAC,CAAC,CAAC,EAAEJ,aAAa,CAACK,gBAAgB,CAAC;EACzE9B,aAAa,CAAC0B,MAAM,CAACK,iBAAiB,CAAC,CAAC,CAAC,EAAEN,aAAa,CAACO,iBAAiB,CAAC;EAC3EhC,aAAa,CAAC0B,MAAM,CAACO,IAAI,CAAC,CAAC,CAAC,EAAER,aAAa,CAACN,IAAI,CAAC;AACnD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}